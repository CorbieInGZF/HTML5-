<!--HTML5 <canvas> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.
<canvas> 标签只是图形容器，您必须使用脚本来绘制图形。-->
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>html5Canvas</title>
</head>
<body>
	<!--一个画布在网页中是一个矩形框，通过 <canvas> 元素来绘制.-->
<canvas id="myCanvas" width="200" height="100" style="border: 1px solid #000000">
	您的浏览器不支持html5标签。
</canvas>
<canvas id="myCanvas2" width="200" height="100" style="border: 1px solid #000000">
	您的浏览器不支持html5标签。
</canvas>
<canvas id="myCanvas3" width="200" height="100" style="border: 1px solid #d3d3d3">
	您的浏览器不支持html5标签。
</canvas>
<canvas id="myCanvas4" width="200" height="100" style="border: 1px solid #d3d3d3">
	您的浏览器不支持html5标签。
</canvas>

<!--canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成-->
<script type="text/javascript">
	var c=document.getElementById("myCanvas");
	var ctx=c.getContext("2d");
	ctx.fillStyle="#f00000";
	ctx.fillRect(0,0,150,75);
	/*canvas 是一个二维网格。
canvas 的左上角坐标为 (0,0)
上面的 fillRect 方法拥有参数 (0,0,150,75)。
意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0-->*/

//画线
    ctx.moveTo(0,0);
    ctx.lineTo(200,100);
    ctx.stroke();
//画圆(圆或部分圆)
    ctx.beginPath();
    ctx.arc(95,50,40,0,2*Math.PI);/*arc(x,y,r,start,stop)*/
    ctx.stroke();
</script>

<script type="text/javascript">
	var c=document.getElementById("myCanvas2");
	var ctx=c.getContext("2d");
	//实心文字
    ctx.font="30px Arial";
    ctx.fillText("Hello World",5,30);
    //空心文字
    ctx.font="30px Arial";
    ctx.strokeText("Hello World",5,60);//strokeText() 方法在画布上绘制文本（无填充色）。文本的默认颜色是黑色。
    //渐变文字
    ctx.font="30px Verdana";
    //创建渐变
    var gradient=ctx.createLinearGradient(0,0,c.width,0);
    gradient.addColorStop("0","magenta");
    gradient.addColorStop("0.5","blue");
    gradient.addColorStop("1.0","red");
    //填充渐变
    ctx.fillStyle=gradient;
    ctx.fillText("big smile!",5,90);
</script>

<script type="text/javascript">
	var c=document.getElementById("myCanvas3");
	var ctx=c.getContext("2d");
    //创建线性渐变
    //创建渐变
    var grd=ctx.createLinearGradient(0,0,200,0);//创建一个线渐变
    grd.addColorStop(0,"red");
    grd.addColorStop(1,"white");
    //填充渐变
    ctx.fillStyle=grd;
    ctx.fillRect(10,10,150,80);
</script>

<script type="text/javascript">
	//径向/圆渐变
    var c=document.getElementById("myCanvas4");
    var ctx=c.getContext("2d");
    //创建渐变
    var grd=ctx.createRadialGradient(75,50,5,90,60,100);//创建一个径向渐变
    grd.addColorStop(0,"red");
    grd.addColorStop(1,"white");
    //填充渐变
    ctx.fillStyle=grd;
    ctx.fillRect(10,10,150,80);
</script>

<img id="scream" src="img_the_scream.jpg" alt="The Scream" width="220" height="277">
<p>Canvas:</p>
<canvas id="myCanvas5" width="250" height="300" style="border: 1px solid #d3d3d3">
	您的浏览器不支持html5标签。
</canvas>
<script type="text/javascript">
	var c=document.getElementById("myCanvas5");
	var ctx=c.getContext("2d");
	var img=document.getElementById("scream");
	img.onload=function(){
	ctx.drawImage(img,10,10);//	向画布上绘制图像、画布或视频。
}
</script>

<canvas id="stroke_Style" width="300" height="150" style="border: 1px solid #d3d3d3">
</canvas>
<script type="text/javascript">
	var a=document.getElementById("stroke_Style");
	var ctx1=a.getContext("2d");
	ctx1.strokeStyle="#FF0000";
	ctx1.strokeRect(20,20,150,100);
</script>

<canvas id="shadow" width="300" height="150" style="border: 1px solid #d3d3d3">
</canvas>
<script type="text/javascript">
	var b=document.getElementById("shadow");
	var ctx2=b.getContext("2d");
	ctx2.shadowBlur=20;
	ctx2.shadowColor="black";
	ctx2.fillStyle="red";
	ctx2.fillRect(20,20,100,80);
</script>

<canvas id="shadowOffset" width="300" height="150" style="border: 1px solid #d3d3d3">
</canvas>
<script type="text/javascript">
	var b=document.getElementById("shadowOffset");
	var ctx3=b.getContext("2d");
	ctx3.shadowBlur=10;
	ctx3.shadowOffsetX=20;
	ctx3.shadowOffsetY=20;
	ctx3.shadowColor="black";
	ctx3.fillStyle="red";
	ctx3.fillRect(20,20,100,80);
</script>

<!--createPattern() 方法在指定的方向内重复指定的元素-->
<p>图片应用：</p>
<img src="img_lamp.jpg" id="lamp">
<p>画布：</p>
<button onclick="draw('repeat')">重复</button>
<button onclick="draw('repeat-x')">重复-x</button>
<button onclick="draw('repeat-y')">重复-y</button>
<button onclick="draw('no-repeat')">不重复</button>
<canvas id="pattern" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	function draw(direction){
		var e=document.getElementById("pattern");
		var ctx4=e.getContext("2d");
		ctx4.clearRect(0,0,e.width,e.height);
		var img=document.getElementById("lamp");
		var pat=ctx4.createPattern(img,direction);
		ctx4.rect(0,0,220,128);
		ctx4.fillStyle=pat;
		ctx4.fill();
	}
</script>

<!--lineCap 属性设置或返回线条末端线帽的样式-->
<p>三种不同的结束线:</p>
<canvas id="line_Cap" width="300" height="150" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。
</canvas>
<script type="text/javascript">
	var f=document.getElementById("line_Cap");
	var ctx5=f.getContext("2d");
	ctx5.beginPath();//起始一条路径或重置当前路径
	ctx5.lineWidth=10;//设置线条宽度
	ctx5.lineCap="butt";//默认。向线条的每个末端添加平直的边缘。
	ctx5.moveTo(20,20);//把路径移动到画布中的指定点，不创建线条。
	ctx5.lineTo(200,20);//添加一个新点，然后在画布中创建从该点到最后指定点的线条。
	ctx5.stroke();//绘制指定的路线

	ctx5.beginPath();
	ctx5.lineCap="round";//	向线条的每个末端添加圆形线帽。
	ctx5.moveTo(20,40);
	ctx5.lineTo(200,40);
	ctx5.stroke();

	ctx5.beginPath();
	ctx5.lineCap="square";//	向线条的每个末端添加正方形线帽。
	ctx5.moveTo(20,60);
	ctx5.lineTo(200,60);
	ctx5.closePath();//创建从当前点回到起始点的路径。(此处并不需要)
	ctx5.stroke();
</script>

<p>closePath()用处：</p>
<canvas id="closePath" width="300" height="150" style="border: 1px solid #d3d3d3;"></canvas>
<script type="text/javascript">
	var f1=document.getElementById("closePath");
	var ctx55=f1.getContext("2d");
	ctx55.beginPath();
	ctx55.moveTo(20,20);
	ctx55.lineTo(20,100);
	ctx55.lineTo(70,100);
	ctx55.closePath();//用于绘制封闭图形时自动返回开始位置
	ctx55.stroke();
</script>

<!--当两条线条交汇时，创建圆形边角：-->
<canvas id="line_Join" width="300" height="150" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。</canvas>
<script>
var g=document.getElementById("line_Join");
var ctx6=g.getContext("2d");
ctx6.beginPath();
ctx6.lineWidth=10;
ctx6.lineJoin="round";//bevel(斜角)miter(默认尖脚)
ctx6.moveTo(20,20);
ctx6.lineTo(100,50);
ctx6.lineTo(20,100);
ctx6.stroke();
</script>

<canvas id="miter_Limit" width="300" height="150" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。
</canvas>
<p>试图设置　miterLimit 4(然后,斜接长度将超过斜接限制),当行满足它将显示为　lineJoin =“bevel”。</p>
<script>
var h=document.getElementById("miter_Limit");
var ctx7=h.getContext("2d");
ctx7.lineWidth=10;
ctx7.lineJoin="miter";
ctx7.miterLimit=5;//数值代表外角到内角的长度
ctx7.moveTo(20,20);
ctx7.lineTo(50,27);
ctx7.lineTo(20,34);
ctx7.stroke();
</script>

<canvas id="clear_Rect" width="300" height="150" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。
</canvas>
<script>
var i=document.getElementById("clear_Rect");
var ctx8=i.getContext("2d");
ctx8.fillStyle="red";
ctx8.fillRect(0,0,300,150);
ctx8.clearRect(20,20,100,50);
</script>

<canvas id="fill" width="300" height="150" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。
</canvas>
<script>
var j=document.getElementById("fill");
var ctx9=j.getContext("2d");
ctx9.rect(20,20,150,100);
ctx9.fillStyle="red";
ctx9.fill();
</script> 

<!--从画布中剪切 200*120 像素的矩形区域。然后，绘制一个红色矩形。只有被剪切区域内的红色矩形部分是可见的-->
<span>没有进行clip():</span>
<canvas id="clip" width="300" height="150" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。
</canvas>
<script>
var k=document.getElementById("clip");
var ctx10=k.getContext("2d");
// 画一个矩形
ctx10.rect(50,20,200,120);
ctx10.stroke();
// 画一个红色矩形
ctx10.fillStyle="red";
ctx10.fillRect(0,0,150,100);
</script> 
<span>有进行clip():</span>
<canvas id="clip2" width="300" height="150" style="border:1px solid #d3d3d3;">
您的浏览器不支持 HTML5 canvas 标签。</canvas>
<script>
var l=document.getElementById("clip2");
var ctx11=l.getContext("2d");
//剪切一个矩形区域
ctx11.rect(50,20,200,120);
ctx11.stroke();
ctx11.clip();
//剪切之后画一个矩形
ctx11.fillStyle="red";
ctx11.fillRect(0,0,150,100);
</script> 


<!--创建一条二次贝塞尔曲线-->
<canvas id="quadraticCurve" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var m=document.getElementById("quadraticCurve");
	var ctx12=m.getContext("2d");
	ctx12.beginPath();
	ctx12.moveTo(20,20);
	ctx12.quadraticCurveTo(20,100,200,20);
	ctx12.stroke();
</script>
<img  src="img_quadraticcurve.gif" width="300" height="200">

<!--创建三次贝塞尔曲线-->
<canvas id="bezierCurve" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var n=document.getElementById("bezierCurve");
	var ctx13=n.getContext("2d");
	ctx13.beginPath();
	ctx13.moveTo(20,20);
	ctx13.bezierCurveTo(20,100,200,100,200,20);
	ctx13.stroke();
</script>
<img  src="img_beziercurve.gif" width="300" height="200">

<!--创建介于两条切线之间的弧线-->
<canvas id="huxian" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var o=document.getElementById("huxian");
	var ctx14=o.getContext("2d");
	ctx14.beginPath();
	ctx14.moveTo(20,20);
	ctx14.lineTo(100,20);
	ctx14.arcTo(150,20,150,70,50);//context.arcTo(x1,y1,x2,y2,r);
	ctx14.lineTo(150,120);
	ctx14.stroke();
</script>

<p>如果点 20,50 位于当前路径中，则绘制一个矩形：</p>
<canvas id="isPath" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var p=document.getElementById("isPath");
	var ctx15=p.getContext("2d");
    ctx15.rect(20,20,150,100);
    if(ctx15.isPointInPath(20,50)){
    	ctx15.stroke();
    }
</script>

<P>绘制矩形，放大到 200%，然后再次绘制矩形：</P>
<canvas id="bigger" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var q=document.getElementById("bigger");
	var ctx15=q.getContext("2d");
	ctx15.strokeRect(5,5,25,15);
	//如果您 scale(2,2)，那么绘图将定位于距离画布左上角两倍远的位置。
	ctx15.scale(2,2);//scale() 方法缩放当前绘图至更大或更小
	//	context.scale(scalewidth,scaleheight);
	ctx15.strokeRect(5,5,25,15);
	ctx15.scale(2,2);//scale() 方法缩放当前绘图至更大或更小
	ctx15.strokeRect(5,5,25,15);	
	ctx15.scale(2,2);//scale() 方法缩放当前绘图至更大或更小
	ctx15.strokeRect(5,5,25,15);	
</script>

<!--将矩形旋转20度-->
<canvas id="xuanzhuan" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var r=document.getElementById("xuanzhuan");
	var ctx16=r.getContext("2d");
    ctx16.rotate(20*Math.PI/180);//旋转20度
    ctx16.fillRect(50,20,100,50);
</script>

<p>转移绘制：</p>
<canvas id="translate" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var s=document.getElementById("translate");
	var ctx17=s.getContext("2d");
    ctx17.fillRect(10,10,100,50);
    ctx17.translate(70,70);//转移到（70.70）再次绘制
    ctx17.fillRect(10,10,100,50);
</script>

<!--绘制一个矩形，通过 transform() 添加一个新的变换矩阵，再次绘制矩形，添加一个新的变换矩阵，然后再次绘制矩形。请注意，每当您调用 transform() 时，它都会在前一个变换矩阵上构建-->
<canvas id="transform" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var t=document.getElementById("transform");
	var ctx18=t.getContext("2d");
	ctx18.fillStyle="yellow";
    ctx18.fillRect(0,0,250,100);

    ctx18.transform(1,0.5,-0.5,1,30,10);//
    ctx18.fillStyle="red";
    ctx18.fillRect(0,0,250,100);

    ctx18.transform(1,0.5,-0.5,1,30,10);//
    ctx18.fillStyle="blue";
    ctx18.fillRect(0,0,250,100);
</script>
<img src="transform参数.PNG" width="500" height="300">

<!--每当您调用 setTransform() 时，它都会重置前一个变换矩阵然后构建新的矩阵，因此在下面的例子中，不会显示红色矩形，因为它在蓝色矩形下面：-->
<canvas id="setTransform" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var u=document.getElementById("setTransform");
	var ctx19=u.getContext("2d");
	ctx19.fillStyle="yellow";
    ctx19.fillRect(0,0,250,100);

    ctx19.setTransform(1,0.5,-0.5,1,30,10);
    ctx19.fillStyle="red";
    ctx19.fillRect(0,0,250,100);

    ctx19.setTransform(1,0.5,-0.5,1,30,10);
    ctx19.fillStyle="blue";
    ctx19.fillRect(0,0,250,100);
</script>

<!--textAlign 属性根据锚点，设置或返回文本内容的当前对齐方式-->
<p>在位置 150 创建一条红线。位置 150 是下面实例中定义的所有文本的锚点。请研究每种 textAlign 属性值的效果：</p>
<canvas id="textAlign" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var v=document.getElementById("textAlign");
	var ctx20=v.getContext("2d");
	//创建一条红线在150位置
	ctx20.strokeStyle="red";
	ctx20.moveTo(150,20);
	ctx20.lineTo(150,170);
    ctx20.stroke();

    ctx20.font="15px Arial";
    
    //不同例子
    ctx20.textAlign="start";
    ctx20.fillText("textAlign=start",150,60);
    ctx20.textAlign="end";
    ctx20.fillText("textAlign=end",150,80);
    ctx20.textAlign="left";
    ctx20.fillText("textAlign=left",150,100);
    ctx20.textAlign="center";
    ctx20.fillText("textAlign=center",150,120);
    ctx20.textAlign="right";
    ctx20.fillText("textAlign=right",150,140);
</script>


<p>在 y=100 处绘制一条红线，然后在 y=100 处用不同的 textBaseline 值放置每个单词：</p>
<canvas id="textBaseline" width="500" height="200" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var w=document.getElementById("textBaseline");
	var ctx21=w.getContext("2d");
	//创建一条红线在5位置
	ctx21.strokeStyle="red";
	ctx21.moveTo(5,100);
	ctx21.lineTo(495,100);
    ctx21.stroke();

    ctx21.font="20px Arial";
    
    //不同例子
    ctx21.textBaseline="top";//textBaseline 属性设置或返回在绘制文本时的当前文本基线
    ctx21.fillText("Top",5,100);
    ctx21.textBaseline="bottom";
    ctx21.fillText("Bottom",50,100);
    ctx21.textBaseline="middle";
    ctx21.fillText("Middle",120,100);
    ctx21.textBaseline="alphabetic";//	默认。文本基线是普通的字母基线
    ctx21.fillText("Alphabetic",190,100);
    ctx21.textBaseline="hanging";
    ctx21.fillText("Hanging",290,100);
    ctx21.textBaseline="ideographic";
    ctx21.fillText("ideographic",390,100);//文本基线是表意基线。
</script>
<img src="img_textbaseline.gif" width="450" height="150">

<canvas id="measure" width="350" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var x=document.getElementById("measure");
	var ctx22=x.getContext("2d");
	ctx22.font="30px Arial";
	var txt="Hello World";
    ctx22.fillText("width:"+ctx22.measureText(txt).width,10,50);//measureText()方法返回一个对象，该对象包含以像素计的指定字体宽度。
    ctx22.fillText(txt,10,100);
</script>

<!--width 属性返回 ImageData 对象的宽度，以像素计。-->
<canvas id="width" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var y=document.getElementById("width");
	var ctx23=y.getContext("2d");
    var imgData=ctx23.createImageData(100,100);
    document.write("imgData的宽度是："+imgData.width+"<br>");
    for(var i=0;i<imgData.data.length;i+=4){
    	imgData.data[i+0]=255;
    	imgData.data[i+1]=0;
    	imgData.data[i+2]=0;
    	imgData.data[i+3]=255;        
    }
    ctx23.putImageData(imgData,10,10);
    /*对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：
R - 红色（0-255）
G - 绿色（0-255）
B - 蓝色（0-255）
A - alpha 通道（0-255; 0 是透明的，255 是完全可见的）*/
    red=imgData.data[0];
    green=imgData.data[1];
    blue=imgData.data[2];
    alpha=imgData.data[3];
    document.write(red + " " + green + " " + blue + " " + alpha);
</script>

<!--通过 getImageData() 复制画布上指定矩形的像素数据，然后通过 putImageData() 将图像数据放回画布：-->
<canvas id="getData" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var z=document.getElementById("getData");
	var ctx24=z.getContext("2d");
    ctx24.fillStyle="red";
    ctx24.fillRect(10,10,50,50);
    function copy(){
    	var imgData=ctx24.getImageData(10,10,50,50);//getImageData() 方法返回 ImageData 对象，该对象拷贝了画布指定矩形的像素数据
    	ctx24.putImageData(imgData,10,70);//	把图像数据（从指定的 ImageData 对象）放回画布上。
    }
</script>
    <button onclick="copy()">复制</button>


<!--首先，绘制一个红色的矩形，然后将透明度 (globalAlpha) 设置为 0.5，然后再绘制一个蓝色和一个绿色的矩形：-->
<canvas id="globalAlpha" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var A=document.getElementById("globalAlpha");
	var ctx25=A.getContext("2d");
    ctx25.fillStyle="red";
    ctx25.fillRect(20,20,75,50);
    //转变透明度
    ctx25.globalAlpha=0.2;
    ctx25.fillStyle="blue";
    ctx25.fillRect(50,50,75,50);
    ctx25.fillStyle="green";
    ctx25.fillRect(80,80,75,50);
</script>

<!--globalCompositeOperation 属性设置或返回如何将一个源（新的）图像绘制到目标（已有的）的图像上。-->
<canvas id="globalCompositeOperation" width="300" height="150" style="border: 1px solid #d3d3d3"></canvas>
<script type="text/javascript">
	var B=document.getElementById("globalCompositeOperation");
	var ctx26=B.getContext("2d");
	//红色矩形是目标图像，蓝色矩形是源图像
	ctx26.fillStyle="red";
	ctx26.fillRect(20,20,75,50);
    ctx26.fillStyle="blue";
	ctx26.globalCompositeOperation="source-over";//源图像在上
	ctx26.fillRect(50,50,75,50);
	ctx26.fillStyle="red";
	ctx26.fillRect(150,20,75,50);
	ctx26.fillStyle="blue";
    ctx26.globalCompositeOperation="destination-over";//目标图像在上
    ctx26.fillRect(180,50,75,50);
</script>
</body>
</html>